# CALayer

CALayer는 이미지 관련 컨텐츠를 관리하는 객체이고 컨텐츠에 애니메이션을 사용하게 한다.

이곳에서 배경색, border, shadow 등을 설정해줄 수 있다.

일반적으로 뷰에 의해 layer 객체를 만들면 이를 layer의 델리게이트로 자동적으로 할당하고 이 관계를 바꿀 수 없다.

하지만 layers를 내가 스스로 만들게 되면 delegate 객체를 할당할 수 있으며 레이어의 컨텐츠를 제공하는 객체를 동적으로 사용할 수 있으며 다른 일들을 수행할 수 있다.

이것이 나오게 된 배경으로는
그래픽관련된 이야기가 나온다.

![image](https://user-images.githubusercontent.com/52434820/172189922-9b473bc5-8fa4-48b1-a998-feb8eafcc9c0.png)

먼저 iOS 어플에서 사용할 때 끊김없이 사용하기 위해서 초당 60 프레임 속도를 유지해야한다.
최근에는 120 프레임으로 늘어나긴 했지만 과거에는 60 프레임 속도를 유지해야했다.

여기에서 이를 유지하기 위해서 GPU에서 직접 실행되는 그래픽에 강력한 Open GL이 생겼따.

장점으로는 빠르게 그래픽 하드웨어에 접근할 수 있으지만 단점으로는 코드의 양이 많아진다.

그래서 Core Graphics를 만들었다!!

이건 Low Level 작업이므로 이를 더 간단하게 만들기 위해서 Core Animation를 만들게 되었다.

하지만, 이것도 실제 앱을 만드는데 불필요한 고급 기능을 제공하고 있기 떄문에 이를 좀 더 간단하게 만들어버리자 해서 나온 것이
UIKit이다.

그래서 UIkit에서 그래픽관련 접근이 가능해진다.

하지만 단점으로는 이로인해 더 제한된 기능을 제공할수밖에 없다. 부피를 줄이고 기능을 제한하여 간단하게 사용하기 위해서 만들었기 떄문이다!!!!

그래서 우리는 UIkit를 활용해서 UIView를 그릴수 있게 된 것이다.

UIView에서 실제로는 레이아웃, 터치 이벤트를 많이 처리하지만 뷰 위에 컨텐츠 그리거나 애니메이션을 넣는 행위를 직접하지 않느다.

이를 Core Animation에게 위임하여 사용하고 있따!!

이곳에서 화면을 그리는데 layer라는 CALayer 타입의 프로퍼티를 통해서 하고있다!!

먼저 UIView는 하나의 CALayer를 가지고 있고
이 CALayer에는 여러개의 SubLayer를 둘 수 있다.

그래서 UIView의 Subview는 UIView의 CALayer 위에 얹혀져 있다.
![image](https://user-images.githubusercontent.com/52434820/172191120-d2aaa7a3-c2f2-412b-a321-b95f008d0c5a.png)

이제 이를 실제로 사용해보도록 하자!

먼저 가장 상위 Root CALayer를 만든다.
```swift
    @IBOutlet weak var myVIew: UIView!
    override func viewDidLoad() {
        super.viewDidLoad()
        myVIew.layer.backgroundColor = UIColor.blue.cgColor
        myVIew.layer.borderColor = UIColor.black.cgColor
        
    }
```

그 다음에 Sublayer들을 만들어서 Root CALayer에 넣어준다.

이는 마치 view에 addSubview해주는 느낌을 받았다!

그 코드는 아래와 같다

```swift
func makeLayers() {
        let layer1: CALayer = CALayer()
        layer1.frame = .init(x: 10, y: 10, width: 30, height: 100)
        layer1.backgroundColor = UIColor.red.cgColor
        myVIew.layer.addSublayer(layer1)
        
        let layer2: CALayer = CALayer()
        layer2.frame = .init(x: 105, y: 10, width: 30, height: 100)
        layer2.backgroundColor = UIColor.brown.cgColor
        myVIew.layer.addSublayer(layer2)
        
        let layer3: CALayer = CALayer()
        layer3.frame = .init(x: 200, y: 10, width: 30, height: 100)
        layer3.backgroundColor = UIColor.black.cgColor
        myVIew.layer.addSublayer(layer3)
    
    }
```

이 코드를 ViewDidLoad() 에서 호출해주면 
아래와같이 보여지게 된다

![Simulator Screen Shot - iPhone 12 - 2022-06-07 at 00 26 42](https://user-images.githubusercontent.com/52434820/172192885-0995e535-b4da-439c-a0c5-c05e276ab5a8.png)

UIView와 무슨차이일까? 

UIView 여러개 생성하는 것보다 더 훨씬 가볍기 떄문에 나은 퍼포먼스를 기대할 수 있다고 한다!!!

하지만 여기에 많은 애니메이션을 넣는담녀 성능상에 문제를 일을켜
속도가 현저히 저하될 수 있으니 이를 조심해야한다.

그래서 이와 같은 성능 저하를 막기 위한 2가지의 프로퍼티가 존재한다.

1번쨰로는 shouldRasterize
```swift
myView.layer.shouldRasterize = false
```

이 프로퍼티는 오직 한 번만 렌더링 할것인지 여부를 지정하는 속성이다.

디폴트 값은 false이다

만약 true로 한다면 처음 한번만 랜더링하고 그 이후 부터 애니메이션은 재홣용된다!!

만약 false라면 애니메이션 될떄마다 레이어의 모양을 다시 그린다!!

그래서 이를 true 해서 성능 향상을 기대할 수 있다.

또한 레이어의 컨텐츠가 화면 주변에서 움직이기는 하나 모양은 변하지 않을 떄 사용한다!!

두 번쨰로는 drawsAsynchronously 이다!

```swift
myVIew.layer.drawsAsynchronously = false
```

이 프로퍼티는 CALayer를 그리는데 필요한 CPU작업을 background thread에서 수행해야하는지 여부를 지정하는 것이다.

false가 기본값인데 그러면 Main thread에서 수행한다.

만약 true라면 Background Thread에서 실행되겠죠?

그래서 레이어의 컨텐츠를 반복적으로 그릴 때 사용하면 성능 향상된다.


https://developer.apple.com/documentation/quartzcore/calayer
https://babbab2.tistory.com/53