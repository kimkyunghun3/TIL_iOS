# 프로토콜

프로토콜은 메소드, 프로퍼티, 기능의 일부나 각각의 일에 맞는 다른 요청사항들의 청사진을 정의한다.

프로토콜은 클래스, 구조체, 열거형에 의해 채택될 수 있으며 그것의 요구사항들의 실제 구현을 제공한다.

어떤 타입이든 프토로콜의 요청에 만족하면 프로토콜을 사용할 수 있다.

맞는 타입들에 대한 특정 요구사항들을  구현하기 위해서는 프로토콜을 확장해서 일부 기능이나 요구사항들을 해결할 수 있다.

프로토콜 문법은 아래와 같다. 이 방식은 클래스, 구조체, 열거형과 비슷하다

```swift
struct SomeStructure: FirstProtocol, AnotherProtocol {
    // structure definition goes here
}
```

커스텀하게 만든 프로토콜은 구조체, 클래스 등에서 추가로 사용할 수 있다. 하나만이 아니라 여러개도 동시에 사용이 가능하다.

```swift
struct SomeStructure: FirstProtocol, AnotherProtocol {
    // structure definition goes here
}

class SomeClass: SomeSuperclass, FirstProtocol, AnotherProtocol {
    // class definition goes here
}
```

클래스에서 만약 슈퍼클래스가 존재한다면 이를 먼저 쓰고 그 다음에 프로토콜을 적는다.

## 프로퍼티 요구사항

프로토콜은 특정한 이름과 타입에 대한 인스턴스 프로퍼티나 타입프로퍼티를 제공하기 위한 적절한 타입을 요청한다. 프로토콜은 그 프로퍼티가 저장 프로퍼티인지 computed 프로퍼티인지를 특정짓지 않는다. 오로지 요청된 프로퍼티의 이름과 타입에만 특정시킨다. 그리고 프로퍼티는 각각의 프로퍼티가 gettable인지 gettable and settable인지 특정짓는다.

만약 프로퍼티가 gettable, settable에 대한 프로퍼티를 요청하면 그 프로퍼티의 요구사항은 상수 저장프로퍼티나 읽을수만 있는 computed 프로퍼티를 사용할 수 없다. gettable 또한 같은 조건으로 그에 맞는 프로퍼티만을 사용할 수 있다.

프로퍼티 요구사항은 항상 변수 프로퍼터로 선언해야하며 var로 써야한다. Gettable, settable인 경우와 Gettable인 경우는 내부에서 다르게 구현해야한다.

```swift
protocol SomeProtocol {
    var mustBeSettable: Int { get set }
    var doesNotNeedToBeSettable: Int { get }
}
```

static를 사용하고 싶다면 앞에 붙여서 사용할 수도 있다

```swift
protocol AnotherProtocol {
    static var someTypeProperty: Int { get set }
}
```

이제 이를 간단한 예시를 통해 어떻게 사용되는지 볼 수 있다.

먼저 프로토콜을 아래와 같이 정의한다.

```swift
protocol FullyNamed {
    var fullName: String { get }
}
```

그 다음 이를 사용할 구조체를 만들어서 사용하는 것을 볼 수 있다.

```swift
struct Person: FullyNamed {
    var fullName: String
}
let john = Person(fullName: "John Appleseed")
// john.fullName is "John Appleseed"
```

더 복잡한 예시로 이처럼 사용할 수도 있다. 클래스에서 저장 프로퍼티를 저장하고 이를 활용해서 fullName을 변환시켜서 사용할 수도 있다.

```swift
class Starship: FullyNamed {
    var prefix: String?
    var name: String
    init(name: String, prefix: String? = nil) {
        self.name = name
        self.prefix = prefix
    }
    var fullName: String {
        return (prefix != nil ? prefix! + " " : "") + name
    }
}
var ncc1701 = Starship(name: "Enterprise", prefix: "USS")
// ncc1701.fullName is "USS Enterprise"
```

## 메서드 요구사항

 메서드도 프로퍼티와 동일하게 맞는 타입에 대한 인스턴스 메서드와 타입메서드들을 특정할 수 있다.

이 메소드들은 프로터컬의 정의의 일부로 같은 방법인 일반적인 인스턴스와 타입메서드처럼 쓰여질 수 있다. 

가변 파라미터가 허락된다 이는 일반적인 메소드와 동일하다! 하지만 기본 값들은 프로토콜의 정의 내에서 메소드의 파라미터를 통해 특정할 수 없다.

하나의 인스턴스 메소드를 요청을 하는 프로토콜을 아래처럼 정의할 수 있다.

```swift
protocol RandomNumberGenerator {
    func random() -> Double
}
```

위의 프로토콜은 랜덤함수로 만들어서 Double type으로 반환하는 것을 볼 수 있다. 이 값은 0.0에서 1.0사이의 값으로 나오는 것을 알 수 있다.

이 프로토콜은 어떻게 랜덤 수가 만들어지는에 대해 추정을 만들지 않았다. 이것은 단순히 새 랜덤 수를 발생시키는 일반적인 방법만을 제공하는 프로토콜이다.

이제 이 프토로콜을 사용하여 어떻게 하는지 볼 수 있다. 이 클래스를 보면 위의 프로토콜을 채택하고 이를 활용해서 랜덤 메소드를 확장시킨 것을 볼 수 있다.

```swift
class LinearCongruentialGenerator: RandomNumberGenerator {
    var lastRandom = 42.0
    let m = 139968.0
    let a = 3877.0
    let c = 29573.0
    func random() -> Double {
        lastRandom = ((lastRandom * a + c)
            .truncatingRemainder(dividingBy:m))
        return lastRandom / m
    }
}
let generator = LinearCongruentialGenerator()
print("Here's a random number: \(generator.random())")
// Prints "Here's a random number: 0.3746499199817101"
print("And another one: \(generator.random())")
// Prints "And another one: 0.729023776863283"
```

## Mutating Method 요청사항

mutating를 사용하는 곳은 Value type에서 사용한다. 왜냐하면 구조체, 열거형은 값을 복사하기 때문에 자신의 인스턴스 메서드 안에서 property를 수정할 수 없다. 그래서 수정이 필요한 mutating 키워드를 사용해야 한다.

그래서 프로토콜을 선언하고 이를 열거형에서 사용하면 아래와 같다.

```swift
protocol Togglable {
    mutating func toggle()
}

enum OnOffSwitch: Togglable {
    case off, on
    mutating func toggle() {
        switch self {
        case .off:
            self = .on
        case .on:
            self = .off
        }
    }
}
var lightSwitch = OnOffSwitch.off
lightSwitch.toggle()
// lightSwitch is now equal to .on
```

## 초기화 요청사항

초기화를 프로토콜에서도 사용할 수 있다.

```swift
protocol SomeProtocol {
    init(someParameter: Int)
}
```

지정 초기화, 편의 초기화 어떤 것이든 사용할 수 있다. 하지만 이를 클래스에서 사용할 때에는 `required`

사용해서 할 수 있다.

맞는 클래스의 모든 서브클래스에서 초기화 요기사항의 상속되거나 특정 구현을 제공한다.

만약 슈퍼클래스로부터 지정된 초기화를 오버라이드하면 프로토콜에서 맞는 초기화 요구사항을 구현할 수 있고 이는 `required override` 를 동시에 사용할 수 있다

```swift
protocol SomeProtocol {
    init()
}

class SomeSuperClass {
    init() {
        // initializer implementation goes here
    }
}

class SomeSubClass: SomeSuperClass, SomeProtocol {
    // "required" from SomeProtocol conformance; "override" from SomeSuperClass
    required override init() {
        // initializer implementation goes here
    }
}
```

또한 실패할 수 있는 초기화에 대해서도 동일하게 구현이 가능하다

## 타입으로써의 프로토콜

프로토콜을 타입으로 사용할 수 있다. 그래서 이를 사용할 수 있는 곳은 아래와 같다

- 함수, 메소드, 초기화에서의 파라미터 타입이나 리턴타입
- 상수, 변수, 프로퍼터의 타입
- 배열, 딕셔너리, 다른 container 에 있는 items의 타입들

이를 타입으로 사용하는 것은 아래와 같은 예시로 볼 수 있다.

```swift
class Dice {
    let sides: Int
    let generator: RandomNumberGenerator
    init(sides: Int, generator: RandomNumberGenerator) {
        self.sides = sides
        self.generator = generator
    }
    func roll() -> Int {
        return Int(generator.random() * Double(sides)) + 1
    }
}
```

## Delegation

클래스나 구조체에서 또 다른 타입의 인스턴스에 책임의 일부를 넘겨주는 것이다. 프로토콜 정의함으로써 이 디자인패턴을 구현할 수 있다. 이는 할당된 책임들을 캡슐화할 수 있다. Delegation는 특정 행동과 자원에 속하는 타입을 알 필요없이 외부 자원으로부터 데이터를 받을 수 있다.

그 예시는 아래와 같다.

```swift
protocol DiceGame {
    var dice: Dice { get }
    func play()
}
protocol DiceGameDelegate: AnyObject {
    func gameDidStart(_ game: DiceGame)
    func game(_ game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int)
    func gameDidEnd(_ game: DiceGame)
}
```

이제 이것을 활용해서 게임을 만드는 것을 볼 수 있다.

```swift
class SnakesAndLadders: DiceGame {
    let finalSquare = 25
    let dice = Dice(sides: 6, generator: LinearCongruentialGenerator())
    var square = 0
    var board: [Int]
    init() {
        board = Array(repeating: 0, count: finalSquare + 1)
        board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02
        board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08
    }
    weak var delegate: DiceGameDelegate?
    func play() {
        square = 0
        delegate?.gameDidStart(self)
        gameLoop: while square != finalSquare {
            let diceRoll = dice.roll()
            delegate?.game(self, didStartNewTurnWithDiceRoll: diceRoll)
            switch square + diceRoll {
            case finalSquare:
                break gameLoop
            case let newSquare where newSquare > finalSquare:
                continue gameLoop
            default:
                square += diceRoll
                square += board[square]
            }
        }
        delegate?.gameDidEnd(self)
    }
}
```

delegate 변수에 프로토콜을 채택해서 이를 play() 메소드에서 활용하는 것을 볼 수 있다.

다음으로 이 클래스를 통해 프로토콜을 통해 3가지 메소드를 구현하는 것을 볼 수 있다.

```swift
class DiceGameTracker: DiceGameDelegate {
    var numberOfTurns = 0
    func gameDidStart(_ game: DiceGame) {
        numberOfTurns = 0
        if game is SnakesAndLadders {
            print("Started a new game of Snakes and Ladders")
        }
        print("The game is using a \(game.dice.sides)-sided dice")
    }
    func game(_ game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int) {
        numberOfTurns += 1
        print("Rolled a \(diceRoll)")
    }
    func gameDidEnd(_ game: DiceGame) {
        print("The game lasted for \(numberOfTurns) turns")
    }
}
```

이를 실제로 사용하려면 아래처럼 사용할 수 있다

```swift
let tracker = DiceGameTracker()
let game = SnakesAndLadders()
game.delegate = tracker
game.play()
// Started a new game of Snakes and Ladders
// The game is using a 6-sided dice
// Rolled a 3
// Rolled a 5
// Rolled a 4
// Rolled a 5
// The game lasted for 4 turns
```