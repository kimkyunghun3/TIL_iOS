# Extension 

확장은 존재하는 클래스, 구조체, 열거형, 프로토콜 타입에 추가적인 기능을 넣기위해서 사용한다.

스위프트에서 확장은 아래와 같은 것을 수행할 수 있다.

- 연산 인스턴스 프로프터와 연산 타입 프로퍼티를 더할 수 있다
- 인스턴스 메소드와 타입 메소드를 정의할 수 있다
- 새 초기화를 제공할 수 있다.
- subscript를 정의할 수 있다.
- 중첩 타입을 정의하고 사용할 수 있다.
- 프로토콜에 맞는 존재하는 타입을 만들 수 있다

확장의 기본 문법은 아래와 같다

```swift
extension SomeType {
    // new functionality to add to SomeType goes here
}
```

확장에서 연산 프로퍼티를 기존의 타입을 이용하여 만들 수 있다.

그 예시로는 아래와 같다.

```swift
extension Double {
    var km: Double { return self * 1_000.0 }
    var m: Double { return self }
    var cm: Double { return self / 100.0 }
    var mm: Double { return self / 1_000.0 }
    var ft: Double { return self / 3.28084 }
}
let oneInch = 25.4.mm
print("One inch is \(oneInch) meters")
// Prints "One inch is 0.0254 meters"
let threeFeet = 3.ft
print("Three feet is \(threeFeet) meters")
// Prints "Three feet is 0.914399970739201 meters"
```

### 초기화

확장은 존재하는 타입에 새 초기화들을 추가할 수 있다.  다른 타입들을 초기화 파라미터를 통해 커스텀한 타입들로 확장할 수도 있고 실제 타입의 원래 구현에 포함되지 않더라도 추가적으로 초기화를 구현할 수도 있다.

확장은 새 편의 초기화를 클래스에 더할 수 있다. 그러나 클래스에 새 지정 초기화를 넣을 수 없고 deinitializer도 추가할 수 없다. 그 말은 즉, 지정 초기화랑 deinitializers는 항상 원래의 클래스 구현에서 제공되어야 한다.

확장에서 값 타입(모든 값이 저장 프로퍼티로 제공하는)에 초기화를 추가하려고 하고 다른 어떤 커스텀 초기화를 제공하지 않다면 기본 초기화를 호출할 수 있고 확장의 초기화 범위 내에서 멤버와이즈 초기화를 호출할 수도 있다.

만약 다른 또다른 모듈에 정의되어 있는 구조체에 초기화를 추가하는 확장을 사용하려고 하면, 새 초기화는 정의된 모듈로 부터 초기화를 호출하기 전까지 `self` 접근 할 수 없다.

위에 대한 예시를 보여주도록 한다.

```swift
struct Size {
    var width = 0.0, height = 0.0
}
struct Point {
    var x = 0.0, y = 0.0
}
struct Rect {
    var origin = Point()
    var size = Size()
}
```

먼저 기본 값을 제공하는 구조체를 제공하고 있다. Rect 구조체는 커스텀한 구조체를 말한다.

여기에서 Rect이 기본 값들을 가지고 있으므로 기본 초기화와 멤버와이즈 초기화를 가지고 있다 이는 아래처럼 사용할 수 있다.

```swift
let defaultRect = Rect()
let memberwiseRect = Rect(origin: Point(x: 2.0, y: 2.0),
   size: Size(width: 5.0, height: 5.0))
```

이 커스텀한 구조체를 확장해서도 사용할 수 있다.

```swift
extension Rect {
    init(center: Point, size: Size) {
        let originX = center.x - (size.width / 2)
        let originY = center.y - (size.height / 2)
        self.init(origin: Point(x: originX, y: originY), size: size)
    }
}

let centerRect = Rect(center: Point(x: 4.0, y: 4.0),
                      size: Size(width: 3.0, height: 3.0))
// centerRect's origin is (2.5, 2.5) and its size is (3.0, 3.0)
```

확장해서 초기화를 사용할 수 있으며 이 초기화는 구조체의 자동적으로 만들어진 멤버와이즈 초기화를 호출할 수 있다.

### Methods

확장은 새 인스턴스 메소드와 타입 메소드를 기존의 타입에 추가할 수 있다. 이 예시는 아래와 같다.

```swift
extension Int {
    func repetitions(task: () -> Void) {
        for _ in 0..<self {
            task()
        }
    }
}

3.repetitions {
    print("Hello!")
}
// Hello!
// Hello!
// Hello!
```

metating 메소드를 활용해서도 확장할 수 있다.

### Subscripts

기존 타입에 서브스크립트를 추가할 수 있다.

```swift
123456789[0] returns 9
123456789[1] returns 8

extension Int {
    subscript(digitIndex: Int) -> Int {
        var decimalBase = 1
        for _ in 0..<digitIndex {
            decimalBase *= 10
        }
        return (self / decimalBase) % 10
    }
}
746381295[0]
// returns 5
746381295[1]
// returns 9
746381295[2]
// returns 2
746381295[8]
// returns 7
```

의미는.. [n] 는 정수의 digit에서 오른쪽에서 몇번 째 인덱스에 있는 값을 내보낼 것인가를 말해주고 있다.

### Nested types

중첩 타입을 사용해서도 확장을 할 수 있다.

```swift
extension Int {
    enum Kind {
        case negative, zero, positive
    }
    var kind: Kind {
        switch self {
        case 0:
            return .zero
        case let x where x > 0:
            return .positive
        default:
            return .negative
        }
    }
}
```

위처럼 중첩으로 타입을 정의해서 확장하고 이를 실제로 사용할 수 있다.

```swift
func printIntegerKinds(_ numbers: [Int]) {
    for number in numbers {
        switch number.kind {
        case .negative:
            print("- ", terminator: "")
        case .zero:
            print("0 ", terminator: "")
        case .positive:
            print("+ ", terminator: "")
        }
    }
    print("")
}
printIntegerKinds([3, 19, -27, 0, -6, 0, 7])
// Prints "+ + - 0 - 0 + "
```

참고사이트

[https://docs.swift.org/swift-book/LanguageGuide/Extensions.html](https://docs.swift.org/swift-book/LanguageGuide/Extensions.html)