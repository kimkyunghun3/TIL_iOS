# understanding swift performance

스위프트의 성능을 분석하기 위해서는 3가지를 생각해야한다.
- Heap vs Stack
- Reference counting 
- Method Dispatch 

Struct vs Class

# Heap vs Stack

구조체를 먼저 봐보도록 하자!

구조체는 Value Type이기 떄문에 Stack에 쌓인다.
구조체에서는 값을 복사해서 사용하기 때문에 동일한 것을 복사해도 새로운 값을 복사해서 사용하기 때문에 서로 영향을 끼치지 않는다

하지만 구조체에서 문제점이 있다.

구조체의 저장 프로퍼티가 참조타입인 경우가 많다.

예를 들어,

```swift
struct Example  {
    var product: String

}
```

이 경우에 product 이라는 프로퍼티는 String 이라는 타입을 가지고 있다. 하지만 String는 참조 타입을 가지고 있다! 그래서 값 타입인 구조체 내부에서 참조 타입은 프로퍼티를 가지고 있는 것다. 

String 는 정해진 크기가 없기 때문에 겉으로는 구조체처럼 보이지만 Heap 영역을 사용하고 있는 참조 타입이다!

만약 이 구조체를 복사해서 사용할 때마다 포인터가 계속 생기게 된다. 그래서 이는 구조체의 장점을 활용할 수 없고 성능 악화를 일으키게 된다.

이와 반대로 클래스를 봐보도록 하자!

클래스에서는 Reference Type이기 때문에 Heap를 사용한다.
동일한 값을 포인터로 가리키기 떄문에 값을 공유해서 사용하고 있다.

그래서 한 곳에서 동일한 프로퍼티의 값을 바꾸게 된다면 다른 곳에서도 이 프로퍼티의 값이 변하게 된다.

이는 다른 곳에서 변한다는 것을 알지 못하기 때문에 문제가 될 수도 있다. 

# Reference Counting

구조체인 경우 값을 복사해서 사용하기 떄문에 Reference Counting이 존재하지 않는다. 그래서 성능상의 이점을 얻을 수 있다.

하지만 내부 저장프로퍼티에 참조 타입을 가지고 있다면 이는 참조 타입을 가지고 있으므로 문제가 될 수 있다.

그래서 이 값들을 예를 들어,

```swift
var uuid: String
var uuid: UUID
```

아래의 프로퍼티처럼 바꿔주어서 참조타입을 값타입으로 바꿀 수 있다

클래스인 경우 값을 참조해서 사용하고 있기 떄문에 Reference Counting를 관리해주어야 한다. 그래서 매번 카운트가 증가하고 감소시키는 것을 잘 활용해야 메모리 누수를 막을 수 있다.

만약 관리하지않고 순환 참조를 발생시킨다면 메모리 누수로 인해 성능을 악화시킬 수 있으므로 주의해야 한다.

# Method Dispatch

Static Dispatch
구조체는 보통 Static Dispatch를 가지고 있다. 이는 컴파일 타임에서 어느 곳으로 갈지 정하게 되고 runtime에 바로 점프해서 가도록 한다.

그래서 컴파일러가 최적화하기 좋은 코드를 가지고 있다.

Dynamic Dispatch
보통 클래스에서 상속이 이루어지기 떄문에 어느 메서드인지 파악이 어렵기 때문에 Dynamic dispatch를 사용한다.

왜냐하면 어느 메서드인지 런타임에 결정하기 떄문에 미리 컴파일 타임에 알 수 없으므로 바로 점프할 수 없다. 실행 중에 호출되는 주소가 생기므로 미리 알 수 가 없다.

그러므로 런타임에 vTable를 모두 확인한 후 이 클래스의 메서드인지 확인한 다음 그곳으로 가서 실행하게 된다.

그래서 클래스에서 성능상의 불리함을 얻을 수 있다.

하지만 이를 해결할 수 있는 방법도 있다!

1. final 선언

final 선언을 통해 이 클래스가 상속의 가능성이 없으므로 현재 메서드로 하면 된다고 알려준다. 그렇게 되면 Static dispatch처럼 동작하게 된다.

### 프로토콜 활용
구조체에서는 상속이 이루어질 수 없으므로 프로토콜을 사용해서 다형성을 구현한다.

여러 곳에 공통적으로 사용할 수 있는 장점이 존재한다! 

protocol에서는 pwt라는 테이블이 존재해서 어느 곳으로 가야할 지 알려주고 있다. 이는 inline으로 할 수 없으므로 클래스처럼 Dynamic dispatch스러운 클래스와 비스슷하다.

그래서 저장 프로퍼티에 프로토콜 타입을 사용하게 되면 최적화하기 어렵다는 단점이 있다.

또한 큰 값을 복사 시에 CoW를 사용할 수 있다. 
만약 구조체에서 참조 타입을 가지고 있을 때에 이를 복사해서 사용할 때 해결할 수 있는 방법으로는, CoW 를 활용할 수 있다.
Copy on Write로 실제 값을 복사한 것처럼 보이지만 이의 포인터만 가지고 있고 

실제 사용시에 할당해줌으로써 메모리 관리를 해주는 것이다.
하지만 Heap allocation, Ref count 사용, Dynamic dispatch 를 사용하는 것이기에 이는 클래스와 별반 차이가 없다.

작은 값들을 사용하는 프로토콜에서는 그래도 조금 다르다. Dynamic dispatch를 제외하고는 구조체와 비슷하긴하다.

### 결론
클래스보다 구조체를 지향하는 스위프트의 뜻을 이해하면서도 프로토콜을 사용하는 시점에서 보았을 때 과연 구조체 + 프로토콜 방식이 옳은 것인가에는 의문이 들었다.

그렇다고 클래스를 사용해서 메모리 성능에 불이익을 얻어야 하는가, 아니면 구조체지향적 코드에서 일부 프로토콜을 사용하는 것이 더 이득인가는 매 상황에 따라 다를 수 있다고 본다.

그래서 각각의 장점이 필요한 시점에 사용하는 것이 더 옳은 방향이지 않을까 싶다!!

결론은...

정답 없는 싸움에 케이스 바이 케이스 라는 의미인 듯싶다.

많은 경험이 필요한 시점이다!