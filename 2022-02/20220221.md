구조체와 클래스의 공통점은 아래와 같다

- 값들을 저장하기 위해 프로퍼티들을 정의한다.
- 기능을 제공하기 위해 메소드를 정의한다
- 서브스크립트 문법을 사용하여 그들의 값을 접근하는 것을 제공하기 위해 서브스크립트를 정의한다.
- 초기화 상태를 설정하기 위해 초기화를 정의한다.
- 기본 실행을 넘어서 그들의 기능을 확장하기 위해 확장시킨다.
- 특정 종류의 기본 기능을 제공하기 위해 프로토콜을 확인한다

클래스는 있고 구조체는 없는 것으로는 아래와 같다.

- 또 다른 특징들의 다른 클래스를 상속할 수 있다.
- 런타임에 타입 캐스팅은 클래스 인스턴스의 타입을 확인하고 해석하게 한다
- 디이니셜라이저는 클래스의 인스턴스에 할당된 어떤 자원을 해제하게 한다.
- Reference counting는 하나 이상의 reference를 클래스 인스턴스하도록 허락한다.

클래스는 사용할수록 증가되는 복잡성의 비용이 크기 떄문에 구조체를 선호한다. 대부분은 구조체와 열거형을 쓰고 위에 클래스에만 있는 특징이 필요할 때만 클래스를 사용한다.

두 부분의 기본 문법은 아래와 같이 제공한다. 

```swift
struct SomeStructure {
    // structure definition goes here
}
class SomeClass {
    // class definition goes here
}
```

class, structure는 UpperCamelCase방식으로 제공되고 내부의 프로퍼티와 method들은 lowerCamelCase로 제공한다.  그에 대한 예시는 아래와 같다.

```swift
struct Resolution {
    var width = 0
    var height = 0
}
class VideoMode {
    var resolution = Resolution()
    var interlaced = false
    var frameRate = 0.0
    var name: String?
}
```

구조체와 클래스 같은 부분은 프로퍼티들을 초기화하여 사용할 수 있다. 또한 클래스 내에서도 resoultion는 구조체 인스턴스를 초기화하여 사용하는 것을 볼 수 있다.

클래스와 구조체를 사용하기 위해서는 먼저 인스턴스를 생성해야한다. 이는 붕어빵 틀에서 붕어빵을 하나 만든다는 의미와 같다. 이는 붕어빵만을 만든 것이고 내부는 위에 제공하는 기본 초기화값 그대로 저장되어 있다. 각각을 사용하여 바꿀 수도 있다.

```swift
let someResolution = Resolution()
let someVideoMode = VideoMode()
```

각 프로퍼티들을 접근하기 위해서는 아래와 같이 사용하면 된다.

```swift
print("The width of someResolution is \(someResolution.width)")
// Prints "The width of someResolution is 0"
```

기본 값이 0으로 초기화되어있기 떄문에 0으로 출력되는 것을 볼 수 있다.

또한 클래스 내에서 구조체 인스턴스를 선언했는데 이를 실제로 사용할 수 있는 것을 볼 수 있다. 또한 값을 바꿔서 사용하는 것도 가능하다

```swift
print("The width of someVideoMode is \(someVideoMode.resolution.width)")
// Prints "The width of someVideoMode is 0"

someVideoMode.resolution.width = 1280
print("The width of someVideoMode is now \(someVideoMode.resolution.width)")
// Prints "The width of someVideoMode is now 1280"
```

### **Memberwise Initializers for Structure Types**

모든 구조체는 자동적으로 멤버와이즈 초기화를 제공한다. 이는 처음 구조체의 인스턴스를 만들면서 구조체 속 프로퍼티의 초기화 값을 설정해줄 수 있다.

```swift
let vga = Resolution(width: 640, height: 480)
```

구조체와 달리 클래스는 기본으로 멤버와이즈 초기화하는 것이 불가능하다!

## **Structures and Enumerations Are Value Types**

Value type는 값을 실제로 복사해서 이를 변수나 상수에 할당한다. 

이제까지 사용한 interger, floation, boolean, string, array, dictionary 등이 value type이고 이는 구조체에서 구현된다.

스위프트에서 모든 구조체와 열거형은 value type이다. 이 말은 즉, 어떤 구조체와 열거형 인스턴스를 생성하든 이는 복사되어서 사용된다는 것을 의미한다.

```swift
let hd = Resolution(width: 1920, height: 1080)
var cinema = hd
```

이 코드를 보면 hd에 Resolution 구조체의 인스턴스를 만든 다음 이를 cinema에 할당해준다면 hd와 cinema 속 들어있는 값은 현재 동일하지만 그러나 둘 인스턴스는 완전히 다른것이다.

그러므로 만약 cinema 속 프로퍼티의 값을 바꾸더라고 hd 속 프로퍼티의 값은 바뀌지 않는 것을 확인할 수 있다.

![https://s3.ap-northeast-2.amazonaws.com/media.yagom-academy.kr/resources/usr/61ee4c272947bf40f08f337c/20220221/62137ee36d880537faa0e489.png](https://s3.ap-northeast-2.amazonaws.com/media.yagom-academy.kr/resources/usr/61ee4c272947bf40f08f337c/20220221/62137ee36d880537faa0e489.png)

이는 열거형에서도 확인해볼 수 있다. 아래처럼 currenctDirection과 rememberedDirection는 다르게 적용되는 것을 확인할 수 있다.

```swift
enum CompassPoint {
    case north, south, east, west
    mutating func turnNorth() {
        self = .north
    }
}
var currentDirection = CompassPoint.west
let rememberedDirection = currentDirection
currentDirection.turnNorth()

print("The current direction is \(currentDirection)")
print("The remembered direction is \(rememberedDirection)")
// Prints "The current direction is north"
// Prints "The remembered direction is west"
```

## **Classes Are Reference Types**

Value type과 다르게 reference type는 값을 복사하지 않는다. 동일한 인스턴스를 사용한다. 이는 포인터 개념과 비슷하다.

```swift
let tenEighty = VideoMode()
tenEighty.resolution = hd
tenEighty.interlaced = true
tenEighty.name = "1080i"
tenEighty.frameRate = 25.0
```

먼저 VideoMode의 클래스 인스턴스를 생성핵서 내부의 값을 설정해줄 수 있다.

그 이후에 다른 상수에 할당하고 그 상수에서 값을 바뀌게 되면 구조체와 다륻게 적용된다는 것을 볼 수 있다.

```swift
let alsoTenEighty = tenEighty
alsoTenEighty.frameRate = 30.0
```

![https://s3.ap-northeast-2.amazonaws.com/media.yagom-academy.kr/resources/usr/61ee4c272947bf40f08f337c/20220221/62137f086d880537faa0e48b.png](https://s3.ap-northeast-2.amazonaws.com/media.yagom-academy.kr/resources/usr/61ee4c272947bf40f08f337c/20220221/62137f086d880537faa0e48b.png)
이처럼 동일한 곳을 바라보고 있기에 한 쪽에서 값을 수정하면 다른쪽도 수정되는 것을 볼 수 있다.

각각 코드에서 다른 부분에 있지만 같은 곳을 바라보고 있기에 때로는 코드 파악에 어려울 수 있다. 왜냐하면 한 곳에서 수정해도 다른 곳에서도 수정이 되기 때문이다.

여기에서 각각 상수로 저장을 한다. 그러나 여전히 바꿀 수 있다. tenEighty.framRate, alsoTenEighty.frameRate를 바꿀 수 있다. 왜냐하면 tenEighty, alsoTenEighty 자신은 ViewMode의 인스턴스를 저장하지 않기 때문이다. 그래서 그들은 각각은 인스턴스 내에서의 변화이지 ViewModel에서 변화를 말한는 것이 아니다.

```swift
if tenEighty === alsoTenEighty {
    print("tenEighty and alsoTenEighty refer to the same VideoMode instance.")
}
// Prints "tenEighty and alsoTenEighty refer to the same VideoMode instance."
```

하지만 두 인스턴스는 동일한 곳을 바라보고 있기 떄문에 구조체와 다르게 identical하다고 본다. 이는 두 인스턴스가 동일하다는 의미가 아니라 동일한 클래스의 인스터를 refer하고 있다는 의미다 이는 “===”로 보여질 수 있다.